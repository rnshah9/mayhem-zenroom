
# Quantum-Proof cryptography

The QP stands for [Quantum-Proof](https://en.wikipedia.org/wiki/Post-quantum_cryptography) (commonly called Post-Quantum) cryptography. The need for these cryptographic primitives is due to the threat posed by quantum computers, in particular from the [Schor's algorithm](https://en.wikipedia.org/wiki/Shor%27s_algorithm) and the [Grover's algorithm](https://en.wikipedia.org/wiki/Grover%27s_algorithm), to the modern cryptography. Regarding the symmetric cryptography this attack can be simply avoided by doubling the length of the secret key. On the other hand the situation for the public key cryptography is worst and the only way out is to use new cryptographic schemes resistant to Quantum computer, so we need new Signature and public key schemes.

In Zenroom, using the *Scanrio qp*, you will have access to the following Quantum-Proof algorithms:
- **Dilithium2** signature scheme
- **Kyber512** Key Encapsulation Mechanism
- **Streamlined NTRU Prime 761** Key Encapsulation Mechanism

# Dilithium

Dilithium2 is a Quantum-Proof signature algorithm defined over lattices. From the user side it works as a modern signature scheme:
- **Key generation**: The *signer* create its private and public keys
- **Signature**: The *signer* use its private key to sign a certain message and sent it to the verifier
- **Verification**: The *verifier*, using the *signer* public key, can verify the authenticity of the message

## Key Generation

### Private key

The script below generates a **dilithium** private key.

[](../_media/examples/zencode_cookbook/qp/dilithium/Dilithium_createprivatekey.zen ':include :type=code gherkin')

The output should look like this:

[](../_media/examples/zencode_cookbook/qp/dilithium/Alice_Dilithium_privatekey.keys ':include :type=code json')

### Public key

Once you have created a private key, you can feed it to the following script to generate the **public key**:

[](../_media/examples/zencode_cookbook/qp/dilithium/Dilithium_createpublickey.zen ':include :type=code gherkin')

The output should look like this:

[](../_media/examples/zencode_cookbook/qp/dilithium/Alice_Dilithium_pubkey.json ':include :type=code json')

## Signature

In this example we'll sign three objects: a string, a string array and a string dictionary, that we'll verify in the next script. Along with the data to be signed, we'll need the private key. The private key is in the file we have generate with the first script, while the one with the messages that we will sign is the following:

[](../_media/examples/zencode_cookbook/qp/dilithium/message.json ':include :type=code json')

The script to **sign** these objects look like this:

[](../_media/examples/zencode_cookbook/qp/dilithium/Dilithium_sign.zen ':include :type=code gherkin')

And the output should look like this:

[](../_media/examples/zencode_cookbook/qp/dilithium/Alice_Dilithium_sign.json ':include :type=code json')

You can now merge this file with the one where your dilithium public key is, so that the verifier has everything he needs in one file. You can do it by either use the command:

```bash
jq -s '.[0]*[1]' pubkey.json signature.json | tee data.json
```

where pubkey.json contains the output of the second script and signature.json the output of the above script, or by adding two rows in the previous script, one where you compute the dilithium public key and the other where you print it.


## Verification

In this section we will **verify** the signatures produced in the previous step. As mentioned above what we will need are the signatures, the messages and the signer public key. So the input file should look like:

[](../_media/examples/zencode_cookbook/qp/dilithium/Alice_Dilithium_data.json ':include :type=code json')

The script to verify these signatures is the following:

[](../_media/examples/zencode_cookbook/qp/dilithium/Dilithium_verifysign.zen ':include :type=code gherkin')

The result should look like:

[](../_media/examples/zencode_cookbook/qp/dilithium/Dilithium_verifysign.json ':include :type=code json')



# Kyber

Kyber512 is a Quantum-Proof Key Encapsulation Mechanism defined over lattices. It is a cryptographic primitive that allows anyone in possession of some partyâ€™s public key to securely transmit a key to that party. It can be divided in three main part:
- **Key generation**: The *recipient* create its private and public keys
- **Encapsulation**: The *sender*, starting from the recipient public key, generate a 32 byte secret and encapsulate it producing a ciphertext that will be sent to the recipient
- **Decapsulation**: The *recipient* can recreate the secret generated by the *sender* using the received ciphertext and its private key

## Key Generation

### Private key

As above, the script below generates a **kyber** private key.

[](../_media/examples/zencode_cookbook/qp/kyber/Kyber_createprivatekey.zen ':include :type=code gherkin')

The output should look like this:

[](../_media/examples/zencode_cookbook/qp/kyber/Alice_Kyber_privatekey.keys ':include :type=code json')

### Public key

You can now generate the **public key** corresponding to your private key by passing the latter as input to the following script:

[](../_media/examples/zencode_cookbook/qp/kyber/Kyber_createpublickey.zen ':include :type=code gherkin')

The output should look like this:

[](../_media/examples/zencode_cookbook/qp/kyber/Alice_Kyber_pubkey.json ':include :type=code json')

## Encapsulation

The script to generate a secret and encapsulate it is as follow:

[](../_media/examples/zencode_cookbook/qp/kyber/Kyber_enc.zen ':include :type=code gherkin')

And the output should look like this:

[](../_media/examples/zencode_cookbook/qp/kyber/Kyber_Kem.json ':include :type=code json')

Now you have to extract and sent to Alice the ciphertext, you can do it for example using the bash command:

```bash
jq 'del(.kyber_secret)' Kyber_Kem.json | tee Kyber_ciphertext.json
```

and send to Alice the file Kyber_ciphertext.json.

## Decapsulation

In this section we will **decapsulate**, and so reconstruct, the secret produced in the previous step by Bob. To perform this action we will need our private key and the ciphertext produced by Bob as input to the following script: 

[](../_media/examples/zencode_cookbook/qp/kyber/Kyber_dec.zen ':include :type=code gherkin')

The result should look like:

[](../_media/examples/zencode_cookbook/qp/kyber/Kyber_secret.json ':include :type=code json')

obviously this secret will be equal to Bob's secret.


# Streamlined NTRU Prime

Streamlined NTRU Prime 761 is a Quantum-Proof Key Encapsulation Mechanism defined over lattices. For simplicity in the following it will be called NTRUP. From the user side it works as Kyber:
- **Key generation**: The *recipient* create its private and public keys
- **Encapsulation**: The *sender*, starting from the recipient public key, generate a 32 byte secret and encapsulate it producing a ciphertext that will be sent to the recipient
- **Decapsulation**: The *recipient* can recreate the secret generated by the *sender* using the received ciphertext and its private key

## Key Generation

### Private key

As above, the script below generates a **NTRUP** private key.

[](../_media/examples/zencode_cookbook/qp/ntrup/ntrup_createprivatekey.zen ':include :type=code gherkin')

The output should look like this:

[](../_media/examples/zencode_cookbook/qp/ntrup/Alice_ntrup_privatekey.keys ':include :type=code json')

### Public key

Once you have created a private key, you can create the corresponding **public key** with the following script:

[](../_media/examples/zencode_cookbook/qp/ntrup/ntrup_createpublickey.zen ':include :type=code gherkin')

The output should look like this:

[](../_media/examples/zencode_cookbook/qp/ntrup/Alice_ntrup_pubkey.json ':include :type=code json')

## Encapsulation

The script to generate a secret and encapsulate it took as input the receiver public key and it is as follow:

[](../_media/examples/zencode_cookbook/qp/ntrup/ntrup_enc.zen ':include :type=code gherkin')

The output should look like this:

[](../_media/examples/zencode_cookbook/qp/ntrup/ntrup_Kem.json ':include :type=code json')

Now you have to extract and sent to Alice the ciphertext, you can do it for example using the bash command:

```bash
jq 'del(.ntrup_secret)' ntrup_Kem.json | tee ntrup_ciphertext.json
```

and send to Alice the file ntrup_ciphertext.json.

## Decapsulation

In this section we will **decapsulate**, and so reconstruct, the secret produced in the previous step by Bob. To perform this action we will need our private key and the ciphertext produced by Bob as input to the following script: 

[](../_media/examples/zencode_cookbook/qp/ntrup/ntrup_dec.zen ':include :type=code gherkin')

The result should look like:

[](../_media/examples/zencode_cookbook/qp/ntrup/ntrup_secret.json ':include :type=code json')

obviously this secret will be equal to Bob's secret.



# The script used to create the material in this page

All the smart contracts and the data you see in this page are generated by the scripts [run_dilithium.sh](https://github.com/dyne/Zenroom/blob/master/test/zencode_qp/run_dilithium.sh), [run_kyber.sh](https://github.com/dyne/Zenroom/blob/master/test/zencode_qp/run_kyber.sh) and [run_ntrup.sh](https://github.com/dyne/Zenroom/blob/master/test/zencode_qp/run_ntrup.sh) . If you want to run the scripts (on Linux) you should: 
 - *git clone https://github.com/dyne/Zenroom.git*
 - install **zsh** and **jq**
 - download a [zenroom binary](https://zenroom.org/#downloads) and place it */bin* or */usr/bin* or in *./Zenroom/src*
